<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>The Query Likelihood Model :: Roberts blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="One of the central ideas behind language modeling is that when a user tries to produce a good search query, he or she will come up with terms that are likely to appear in a relevant document. In other words, a relevant document is one that..." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://rsokolewicz.github.io/posts/2_query_likelihood/" />




<link rel="stylesheet" href="https://rsokolewicz.github.io/assets/style.css">



<link rel="stylesheet" href="https://rsokolewicz.github.io/assets/css/style.css">
<link rel="stylesheet" href="https://rsokolewicz.github.io/assets/css/hugo-cite.css">


<link rel="apple-touch-icon" href="https://rsokolewicz.github.io/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://rsokolewicz.github.io/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="The Query Likelihood Model">
<meta property="og:description" content="One of the central ideas behind language modeling is that when a user tries to produce a good search query, he or she will come up with terms that are likely to appear in a relevant document. In other words, a relevant document is one that..." />
<meta property="og:url" content="https://rsokolewicz.github.io/posts/2_query_likelihood/" />
<meta property="og:site_name" content="Roberts blog" />

  <meta property="og:image" content="https://rsokolewicz.github.io">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2022-04-18 00:00:00 &#43;0000 UTC" />













<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            macros: {
                bb: ["{\\boldsymbol{#1}}", 1],
                tr: "{\\DeclareMathOperator{\\tr}{Tr}}",
                im: "{\\DeclareMathOperator{\\im}{Im}}",
                re: "{\\DeclareMathOperator{\\re}{Re}}",

                
                
                
                
                
                
                
                
                
                
            },
            processEscapes: true,
            processEnvironments: true,
            tags: "ams"
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    };

    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function (x) {
            x.parentElement.classList += 'has-jax'
        })
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Home
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/cv">CV</a></li>
        
      
        
          <li><a href="/physics">Physics</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/cv">CV</a></li>
      
    
      
        <li><a href="/physics">Physics</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://rsokolewicz.github.io/posts/2_query_likelihood/">The Query Likelihood Model</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2022-04-18
        
      </span>
    
    
      <span class="post-author">:: Robert</span>
    
    
  </div>

  
  


  

  <div class="post-content"><div>
        <h1 id="language-models">Language Models<a href="#language-models" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>One of the central ideas behind language modeling is that when a user tries to produce a good search query, he or she will come up with terms that are likely to appear in a relevant document. In other words, a relevant document is one that is likely to contain the query terms. What makes language modeling different from other probabilistic models, is that it creates a language model for each document from which probabilities are generated that correspond to the likelihood that a query can be found in that document. This probability is given by $P(q|M_d)$.</p>
<p>The definition of a language model is a function that produces probabilities for a word or collection of words (e.g. a (part of a) sentence) given a vocabulary. Let us look at an example of a model that produces probabilities for single words:</p>
<table>
<thead>
<tr>
<th>s</th>
<th>cat</th>
<th>dog</th>
<th>likes</th>
<th>fish</th>
</tr>
</thead>
<tbody>
<tr>
<td>$P(s)$</td>
<td>0.3</td>
<td>0.1</td>
<td>0.2</td>
<td>0.2</td>
</tr>
</tbody>
</table>
<p>The probability for the sentence &ldquo;cat likes fish&rdquo; is $0.3\times0.2\times0.2 = 0.012$, whereas the probability for the sentence &ldquo;dog likes cat&rdquo; is $0.1\times0.2\times0.3 = 0.006$. This means that the term &ldquo;cat likes fish&rdquo; is more likely to appear in the document than &ldquo;dog likes cat&rdquo;. If we want to compare different documents with the same search query, we produce the probability for each document separately. Remember that each document has its own language model with different probabilities.</p>
<p>Another way of interpreting these probabilities is asking how likely it is that this model generates the sentence &ldquo;cat likes fish&rdquo; or &ldquo;dog likes cat&rdquo;. (Technically speaking you should also include probabilities how likely it is that a sentence continues or stops after each word). These sentences don&rsquo;t have to exist in the document, nor do they have to make sense. In this language model for example, the sentences &ldquo;cat likes fish&rdquo; and &ldquo;cat fish fish&rdquo; have the same probability, in other words they are equally likely to be generated.</p>
<p>The language model from the example above is called a unigram language model, it is a model that estimates each term independently and ignores the context. One language model that does include context is the bigram language model. This model includes conditional probabilities for terms given that they are preceded by another term. The probability for &ldquo;cat likes fish&rdquo; would be given by</p>
<p>$$ P(\text{cat}) \times P(\text{likes}|\text{cat}) \times P(\text{fish}|\text{likes}). $$</p>
<p>This of course requires all conditional probabilities to exist.</p>
<p>More complex models exist, but they are less likely to be used. Each document creates a new language model, but the training data within one document is often not sufficiently large enough to accurately train a more complex model. This is reminiscent of the bias-variance trade-off. Complex models have high variance and are prone to overfitting on smaller training data.</p>
<h1 id="the-query-likelihood-model">The Query Likelihood Model<a href="#the-query-likelihood-model" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>When ranking documents by how relevant they are to a query, we are interested in the conditional probability $P(d|q)$. In the query likelihood model, this probability is so-called rank-equivalent to $P(q|d)$, so that we only need to use the probabilities discussed above. To see why they are rank-equivalent let us look at Bayes Rule:</p>
<p>$$ P(d|q) = P(q|d) P(d) / P(q) $$</p>
<p>Since $P(q)$ has the same value for each document, it will not affect the ranking at all. $P(d)$ on the other hand is treated as being uniform for simplicity and so will not affect the ranking either (in more complicated models $P(d)$ could be made dependent on the length of the document for example). And so, the probability $P(d|q)$ is equivalent to $P(q|d)$. In other words, in the query likelihood model the following two statements are <em>rank-equivalent</em></p>
<ul>
<li>
<p>The likelihood that document d is relevant to query q.</p>
</li>
<li>
<p>The probability that query q is generated by the language of document d.</p>
</li>
</ul>
<p>When a user creates a query, he or she already has an idea of how a relevant document could look like. The terms used in the query are more likely to appear in relevant documents than in non-relevant documents.</p>
<p>One way of estimating the probability $P(q|d)$ for a unigram model is using the maximum likelihood estimation</p>
<p>$$ P(Q|M_d) = \Pi_{t\in q} P_{\text{mle}}(T|M_d) = \Pi_{t\in q}\frac{\text{tf}_{t,d}}{L_d}$$</p>
<p>Where $\text{tf}_{t,d}$ is the term frequency of term $t$ in document $d$ and $L_d$ is the size of document $d$. In other words, calculate the fraction of how often each query word appears in document $d$ compared to all words in that document, and then multiply all those fractions with each other.</p>
<p>There are two small problems with the formula above. First, if one the terms in the query does not appear in a document, the entire probability $P(q|d)$ will be zero. In other words, the only way to get a non-zero probability is if each term in the query appears in the document. The second problem is that the probability of the terms that appear less frequently in the document are likely to be overestimated.</p>
<p>The solution to these problems is to introduce smoothing. Smoothing will help by creating non-zero probabilities for terms that do not appear in the document, and by creating effective weights to frequent terms. Different smoothing techniques exist such as Jelinek-Mercer smoothing, that uses a linear combination of document-specific and collection-specific maximum likelihood estimations</p>
<p>$$ P(T|d) = \lambda P_\text{mle} (t|M_d) +(1-\lambda)P_\text{mle}(t|M_c) $$</p>
<p>where $0&lt;\lambda&lt;1$ is a hyperparameter that can be finetuned and $M_c$ is a language model created on the entire document collection. Another popular smoothing technique is Dirichlet smoothing</p>
<p>$$ P(t|d) = \frac{\text{tf}_{t,d}+\alpha P(t|M_c)}{L_d + \alpha} $$</p>
<p>(parts of this article also appear in this <a href="https://medium.com/towards-data-science/understanding-term-based-retrieval-methods-in-information-retrieval-2be5eb3dde9f">Medium post</a> about term-based retrieval methods in information retrieval I wrote with my gf)</p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        
        <span class="button next">
            <a href="https://rsokolewicz.github.io/posts/1_copy_large_amounts_of_files/">
                <span class="button__text">Copy large amounts of files over ssh</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  
  

  
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2023 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://rsokolewicz.github.io/assets/main.js"></script>
<script src="https://rsokolewicz.github.io/assets/prism.js"></script>







  
</div>

</body>
</html>
