<!doctype html><html lang=en><head><title>Unit testing - Classical vs. London Approaches :: Roberts blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A small post about the need for unit for unit testing in software projects, and the differences between London-style and Classical-style unit-testing."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://www.robert-sokolewicz.nl/posts/14_unit_testing/><link rel=stylesheet href=https://www.robert-sokolewicz.nl/assets/style.css><link rel=stylesheet href=https://www.robert-sokolewicz.nl/assets/css/hugo-cite.css><link rel=apple-touch-icon href=https://www.robert-sokolewicz.nl/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://www.robert-sokolewicz.nl/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Unit testing - Classical vs. London Approaches"><meta property="og:description" content="A small post about the need for unit for unit testing in software projects, and the differences between London-style and Classical-style unit-testing."><meta property="og:url" content="https://www.robert-sokolewicz.nl/posts/14_unit_testing/"><meta property="og:site_name" content="Roberts blog"><meta property="og:image" content="https://www.robert-sokolewicz.nl/img/favicon/orange.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2023-09-24 00:00:00 +0000 UTC"><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],macros:{bb:["{\\boldsymbol{#1}}",1],tr:"{\\DeclareMathOperator{\\tr}{Tr}}",im:"{\\DeclareMathOperator{\\im}{Im}}",re:"{\\DeclareMathOperator{\\re}{Re}}",},processEscapes:true,processEnvironments:true,tags:"ams"},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script type=text/x-mathjax-config>
    MathJax.Hub.Queue(function() {
        // Fix <code> tags after MathJax finishes running. This is a
        // hack to overcome a shortcoming of Markdown. Discussion at
        // https://github.com/mojombo/jekyll/issues/199
        var all = MathJax.Hub.getAllJax(), i;
        for(i = 0; i &lt; all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    </script></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Home</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/books>Book Reviews</a></li><li><a href=/cv>CV</a></li><li><a href=/physics>Physics</a></li><li><a href=/reading_papers>Reading Papers</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/books>Book Reviews</a></li><li><a href=/cv>CV</a></li><li><a href=/physics>Physics</a></li><li><a href=/reading_papers>Reading Papers</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://www.robert-sokolewicz.nl/posts/14_unit_testing/>Unit testing - Classical vs. London Approaches</a></h1><div class=post-meta><span class=post-date>2023-09-24</span>
<span class=post-author>:: Robert</span></div><div class=post-content><div><p>Most, if not all, software projects suffer from the same problem. When starting the project it&rsquo;s very easy to include new features. One feature might take one day to implement, but as the code base grows, implementing something new will take a week, a month, or half a year until it&rsquo;s impossible to implement something without breaking something else. Different parts of the code depend on each other and this can create a cascading effect where a small change propagates throughout the entire codebase breaking a lot of stuff.</p><p>Unit tests are safeguards that help the developer in writing code that does not break the existing code, making it easier to make progress when working on the codebase.</p><figure class=center><img src=images/1.svg><figcaption class=center>Figure 1. The time that we spend on developing and expanding the code base grows exponentially with the amount of progress already made.</figcaption></figure><p>In the early stages of a project, it is probably easier and faster to implement new features than it is to write unit tests for them. For smaller projects implementing unit tests might even hinder the progress of the project, but in the long run, it is worthwhile.</p><h2 id=what-is-a-unit-test>What is a unit test?<a href=#what-is-a-unit-test class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Let&rsquo;s assume that our codebase has a <code>Cat</code> class that represents a cat that can meow and always feels hungry until it gets some food to eat. Some unit tests for this class could be something like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_is_hungry</span>():
    cat <span style=color:#f92672>=</span> Cat(<span style=color:#e6db74>&#34;funnywhiskers&#34;</span>)
    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>is_hungry <span style=color:#f92672>is</span> True

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_meow</span>():
    cat <span style=color:#f92672>=</span> Cat(<span style=color:#e6db74>&#34;funnywhiskers&#34;</span>)
    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>meow() <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Meow!&#34;</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_eat</span>():
    cat <span style=color:#f92672>=</span> Cat(<span style=color:#e6db74>&#34;funnywhiskers&#34;</span>)
    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>eat() <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Yum!&#34;</span>
    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>is_hungry() <span style=color:#f92672>is</span> False
    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>eat() <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;I&#39;m not hungry.&#34;</span>
</code></pre></div><p>In this example, we see that even though we have one <code>Cat</code> class, the tests are split into smaller pieces, each testing a small aspect of that class. This is where the name &ldquo;unit&rdquo; comes from. Furthermore, each test is small, to the point, and fast. And lastly, each test is <em>isolated</em> from each other. What isolation means exactly, we will explain shortly.</p><p>A unit test has the following properties:</p><ol><li>it verifies a piece of code.</li><li>it is fast.</li><li>it is isolated.</li></ol><p>The requirement that a unit test is isolated is something that many people have strong opinions about, so strong even, that we broadly have two schools of thought: The London (mockist) and the Detroit (classical) school.</p><h2 id=the-classic-view-of-isolation>The classic view of isolation<a href=#the-classic-view-of-isolation class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Let us examine the classical school first. Imagine that our cat codebase has grown quite a bit and now we also have an <code>Owner</code> class that is responsible for getting the food for the cat. Again, a simple test to test this functionality would be</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_classical_eat</span>():
    cat <span style=color:#f92672>=</span> Cat(<span style=color:#e6db74>&#34;funnywhiskers&#34;</span>)
    owner <span style=color:#f92672>=</span> Owner(<span style=color:#e6db74>&#34;Robert&#34;</span>)
    food <span style=color:#f92672>=</span> owner<span style=color:#f92672>.</span>get_food(<span style=color:#e6db74>&#34;fish&#34;</span>)

    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>eat(food) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Yum! Ate fish.&#34;</span>
    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>is_hungry <span style=color:#f92672>is</span> False
</code></pre></div><p>There is a small issue with this test, however. We are testing whether the <code>.eat</code> method and <code>.is_hungry</code> method are working as intended, but what if we introduce a change in the codebase corresponding to the <code>Owner.get_food</code> method in such a way that <code>cat.eat(food) != "Yum! Ate fish."</code>. The test will fail, but not because anything is wrong with our cat, but because we changed the behavior elsewhere. This is the classic example of touching one part of the code and it breaks something else. This cascading effect of a bug that propagates throughout the code base and fails a lot of tests, is not necessarily wrong. If many tests fail because we made a change to <code>.get_food</code> it means that the codebase heavily depends on it and we discovered that it&rsquo;s quite an essential piece of code.</p><p>The downside, however, is that when a lot of tests fail it becomes difficult to isolate where the problem exactly is. As mentioned, in this case, we&rsquo;re testing the eating behavior of the cat, but the problem lies in the <code>.get_food</code> method of <code>Owner</code>. And according to the Londonists, this is due to isolation.</p><h2 id=the-london-view-of-isolation>The London view of isolation<a href=#the-london-view-of-isolation class=hanchor arialabel=Anchor>&#8983;</a></h2><p>When testing a piece of code that depends on other parts of the codebase, the Londonists say we should replace those dependencies with dummies (also called doubles or mocks). The above test then becomes</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_london_eat</span>(pytest_mock):
    mock_owner <span style=color:#f92672>=</span> pytest_mock<span style=color:#f92672>.</span>Mock(spec<span style=color:#f92672>=</span>Owner)
    mock_owner<span style=color:#f92672>.</span>get_food<span style=color:#f92672>.</span>return_value <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fake fish&#34;</span>
    
    cat <span style=color:#f92672>=</span> Cat(<span style=color:#e6db74>&#34;funnywhiskers&#34;</span>)
    food <span style=color:#f92672>=</span> mock_owner<span style=color:#f92672>.</span>get_food(<span style=color:#e6db74>&#34;fake fish&#34;</span>)
    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>eat(food) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Yum! Ate fake fish.&#34;</span>
    <span style=color:#66d9ef>assert</span> cat<span style=color:#f92672>.</span>is_hungry <span style=color:#f92672>is</span> False
</code></pre></div><p>where we used the mocking capability of pytest to create a fake version of <code>Owner</code>. The line <code>mock_owner.get_food.return_value</code> sets the return value of <code>get_food</code> regardless of how <code>get_food</code> is implemented in the code base.</p><h2 id=a-note-on-dependencies>A note on dependencies<a href=#a-note-on-dependencies class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In the classical style of testing, it is still important that unit tests do not depend on each other. Certain dependencies that are shared, should still be mocked even in the classical style. For example, updating a shared database might cause issues with other tests that operate on the same database. Imagine a hundred tests that all add the same cat named <em>funnywhiskers</em> to the database. This can cause many problems while testing, either because the database requires unique cat names or maybe because there is a test that adds and removes <em>Funnywhiskers</em> from the database and asserts that no there is no <em>Funnywhiskers</em> in the database anymore.</p><h2 id=comparisons>Comparisons<a href=#comparisons class=hanchor arialabel=Anchor>&#8983;</a></h2><p>As mentioned above, isolation in the London school attempts to isolate dependencies and as such test small &ldquo;units&rdquo; of code. This has a few side effects though (some positive, some negative). These tests tend to be more focussed on the implementation of code, rather than the behavior of code. In the <code>get_food</code> example, if we refactor the code so that <code>get_food</code> returns an instance of a <code>Food</code> object, and <code>.eat</code> accepts this food instance the classical test will pass, whereas the London test will fail because <code>get_food</code> is mocked in a way to return a <code>str</code> object, rather than a <code>Food</code> object. Consequently, classical tests generally protect better against code refactors.</p><p>One benefit of London-style testing is that if you have a large code base with a lot of tests, if you introduce a bug in an important piece of code it will only cause relevant tests to fail and allow you to quickly figure out where you introduced the bug. In the classical style of unit testing, you will see many more tests that fail because of the dependency issue. If you run all the unit tests frequently however, (e.g. with every commit or even more often) you should be able to quickly figure out what went wrong anyway because you haven&rsquo;t made many changes yet. So in practice, this shouldn&rsquo;t be too big of a problem for developers.</p><table><thead><tr><th>Aspect</th><th>Classical (Detroit) School</th><th>London (Mockist) School</th></tr></thead><tbody><tr><td><strong>Isolation</strong></td><td>Units are not isolated from each other; only the tests are isolated.</td><td>Units under test are isolated from each other.</td></tr><tr><td><strong>Unit Under Test</strong></td><td>A unit of behavior.</td><td>A unit of code, usually a class.</td></tr><tr><td><strong>Dependencies</strong></td><td>Only shared dependencies are replaced with test doubles.</td><td>All dependencies except immutable ones are replaced with test doubles.</td></tr><tr><td><strong>Granularity</strong></td><td>May not provide as fine-grained control as the London School.</td><td>Provides better granularity.</td></tr><tr><td><strong>Ease of Testing</strong></td><td>Less focused on ease of testing large graphs of interconnected classes.</td><td>Makes it easier to test large graphs of interconnected classes.</td></tr><tr><td><strong>Debugging</strong></td><td>Doesn&rsquo;t make it particularly easy or hard to find which functionality contains a bug.</td><td>Easier to find which functionality contains a bug.</td></tr><tr><td><strong>Issues</strong></td><td>Does not hide issues with code design.</td><td>May hide issues with code design due to focus on units of code rather than units of behavior.</td></tr><tr><td><strong>Over-Specification</strong></td><td>Less likely to couple tests to the system under test’s (SUT’s) implementation details.</td><td>Higher risk of over-specification; tests could become coupled to the SUT’s implementation details.</td></tr></tbody></table></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://www.robert-sokolewicz.nl/posts/15_gmail_labels/><span class=button__icon>←</span>
<span class=button__text>Google Scripts to label GitLab related emails</span></a></span>
<span class="button next"><a href=https://www.robert-sokolewicz.nl/posts/13_gitlab_docker/><span class=button__text>Debugging gitlab pipeline docker containers</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://www.robert-sokolewicz.nl/assets/main.js></script><script src=https://www.robert-sokolewicz.nl/assets/prism.js></script></div></body></html>